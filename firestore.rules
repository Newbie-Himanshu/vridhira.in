rules_version = '2';

/**
 * Vridhira Marketplace Security Rules
 * 
 * CORE PHILOSOPHY:
 * This ruleset enforces a strict user-ownership model for personal profiles and a 
 * role-based access control system for administrative functions. Security is 
 * prioritized by ensuring that user data is isolated by UID and administrative 
 * privileges are verified against a dedicated roles collection.
 * 
 * DATA STRUCTURE:
 * - /users/{userId}: Private user profile information, owned by the individual user.
 * - /roles_admin/{userId}: A lookup collection where the presence of a document 
 *   grants administrative rights to the user with the matching UID.
 * 
 * KEY SECURITY DECISIONS:
 * - Path-Based Authorization: User data access is tied directly to the {userId} 
 *   variable in the document path, which must match the authenticated user's UID.
 * - Administrative Lookup: Admin privileges are determined using an `exists()` 
 *   check on the `/roles_admin/` collection. This provides a central, secure 
 *   mechanism for revenue and order management.
 * - Relational Integrity: On user profile creation, the rules enforce that the 
 *   internal 'id' field matches the document ID to maintain data consistency.
 * - Prototyping Flexibility: While authorization is strictly enforced, the 
 *   internal schema of documents (fields and types) is not validated to allow 
 *   for rapid development.
 */

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---

    /** @description Checks if the request comes from an authenticated user. */
    function isSignedIn() {
      return request.auth != null;
    }

    /** @description Checks if the authenticated user's UID matches the provided userId. */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /** @description Checks if the authenticated user has an entry in the admin roles collection. */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /** @description Combines ownership check with a verification that the document exists for destructive operations. */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // --- Collection Rules ---

    /**
     * @description Rules for the User collection. Ensures users can only access and manage their own profile.
     * @path /users/{userId}
     * @allow (get) If auth.uid is 'user_123' and path is /users/user_123.
     * @deny (list) If auth.uid is 'user_123' and attempting to list /users/ (listing the root is not permitted).
     * @principle Restricts access to a user's own data tree and enforces relational integrity of the ID field.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the admin roles collection. Used for DBAC (Document Based Access Control).
     * @path /roles_admin/{userId}
     * @allow (get) If auth.uid is 'user_123' and checking their own admin status at /roles_admin/user_123.
     * @deny (create) If auth.uid is 'user_123' and they are not already an admin.
     * @principle Centralizes administrative authorization logic through a dedicated lookup collection.
     */
    match /roles_admin/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }
  }
}